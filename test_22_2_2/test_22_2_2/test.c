#define _CRT_SECURE_NO_WARNINGS 1 
#include <stdio.h>
#include <string.h>
//int main()
//{
//	int arr[] = { 1, 2, (3, 4 ),5 };
//	//(3,4)是逗号表达式，从左向右依次计算，表达式的结果是最后一个表达式的结果
//	printf("%d\n", sizeof(arr));
//	return 0;
//}

//int main()
//{
//	char str[] = "hello bit";
//	printf("%d %d \n", sizeof(str), strlen(str));//sizeof计算的长度包含结束标识'\0'
//												 //strlen计算的长度不包含'\0'
//	return 0;
//}

//int main()
//{
//	char acX[] = "abcdefg";//八个元素
//	char acY[] = { 'a','b','c','d','e','f','g' };//七个元素
//	//两者字符串长度无法比较，数组长度acX大于acY
//	return 0;
//}


//二维数组行可以省略，列不可以省略，（编译器会报错）

//数组操作
// 创建一个整型数组，完成以下操作
// 实现函数init（），初始化数组全为0
// 实现print（） 打印数组的每个元素
// 实现reverse（） 函数完成数组的逆置
void init( int arr[], int sz);
void print(int* p,int sz);
void reverse(int* p,int sz);
//int main()
//{
//	int arr[20] = { 1,2,3,4,5,6,7,8,9,10 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//sz 的值是20， arr[0]+sz会造成栈溢出
//	init(arr, sz);
//	print(arr,sz);
//	reverse(arr, sz);
//	printf("\n");
//	print(arr, sz);
//	return 0;
//}
void init(int arr[], int sz)
{
	for (int i = 0;i < sz; i++)
		scanf("%d", &arr[i]);
}
void print(int* p,int sz )
{
	for (int i = 0; i < sz; i++)
		printf("%d\t ", *(p + i));
}
void reverse(int* p, int sz)
{
	int* left = p;
	int* right = p+sz-1;
	/*for (; left < right; left++, right--)
	{
		int temp = *left;
		*left  = *right;
		*right = temp;
	}*/
	while (left < right)
	{
		int temp = *left;
		*left = *right;
		*right = temp;
		left++;
		right--;
	}
}

//将数组A和数组B中的内容进行交换，A和B一样大
//int main()
//{
//	int arr1[] = { 1,3,5,7,9 };
//	int arr2[] = { 2,4,6,8,10 };
//	int temp = 0;
//
//	int i = 0;
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	for (i = 0; i < sz; i++)
//	{
//		temp = arr1[i];
//		arr1[i] = arr2[i];
//		arr2[i] = temp;
//	}
//	return 0;
//}


//操作符详解
// 算术操作符
//int main()
//{
//	int ret = 10 % (-3);//%取模（余） - 得到的是相除后的余数
//	//模负数时负号无效
//  //%操作符的两个操作数必须是整数，返回的是整除之后的余数
//	int ret1 = 10 / 3; // 除法 - 商
//
//	printf("%d\n", ret);
//	//当 / (除号)两端都是整数时，执行的是整数除法；两端只要有一个浮点数，执行的就是浮点数的除法
//	double ret2 = 10 / 3.0;
//	printf("%lf\n", ret2);
//	return 0;
//}

//移位操作符
//int main()
//{
//	// 移位操作符的操作数必须是整数
//	//                                    左移操作符
//	int a = 5;
//	//把a在内存中的存储的二进制位（补码）移动两位
//	//                                   整数有三种二进制的表示形式                           int a = 5;  // a 是整型，占4个字节->32bit
//	//                                   原码                                                 00000000000000000000000000000101  - 原码
//	//                                   反码                                                 00000000000000000000000000000101  - 反码
//	//                                   补码                                                 00000000000000000000000000000101  - 补码
//	//                                   正整数 - 原码 补码 反码相同                          int a = -5;
//	//                                   负整数 - 原码、反码、 补码不同，要进行计算           10000000000000000000000000000101  - 原码
//	//                                   计算方法 - 原码的符号位不变，其他位按位取反的反码    11111111111111111111111111111010  - 反码
//	//                                              反码的二进制+1，得补码                    11111111111111111111111111111011  - 补码
//	//                                   整数在内存中存储的是补码！！！！！
//	int b = a << 2;
//	// 00000000000000000000000000010100  - 补码
//	printf("%d\n", b);
//	printf("%d\n", a);//a本身不变，只是把左移两位的效果展现出来放到b中
//	int c = -5;
//	int d = c << 2;
//	// 11111111111111111111111111101100  - 补码
//	// 11111111111111111111111111101011  - 反码
//	// 10000000000000000000000000010100  - 原码 -> -20
//	printf("%d\n", d);
//	printf("%d\n", c);
//	
//	return 0;
//}
 
 
//                            右移操作符：
//                            1. 算术右移(右边丢弃，左边补原来的符号位）
//                            2. 逻辑右移（右边丢弃，左边补0）
//                            到底右移是算术右移还是逻辑右移，取决于编译器，常见的编译器下都是算术右移
//                            对正数来说，两种右移方法没有区别
//                            对负数来说，
//int main()
//
//{
//	int a = 5;
//	int b = a >> 1;
//	// 00000000000000000000000000000010 - 补码
//	printf("%d\n",b);
//	printf("%d\n",a);
//	int c = -5;
//	int d = c >> 1;
//	//算术右移
//	// 11111111111111111111111111111101  - 补码
//	// 11111111111111111111111111111100  - 反码
//	// 10000000000000000000000000000011  - 原码 -> -3
//	printf("%d\n", d);
//	printf("%d\n", c);
//
//	return 0;
//}


//int main()
//{ 
//	int a = 5;
//	int b = a>> -2;//标准未定义行为,error
//
//	return 0;
//}


//位操作符                      只能用于整型！！！！！！
//& - 按（2进制）位与(补码）
//| - 按（2进制）位或
//^ - 按（2进制）位异或 (相同为0，相异为1）

//int main()
//{
//	int a = 3;
//	int b = -5;
//
//	int c = a & b;
//	// 00000000000000000000000000000011 - 3的补码
//	// 11111111111111111111111111111011 - -5的补码
//	// 00000000000000000000000000000011 - 按位与
//	printf("%d\n", c);
//
//	int d = a | b;
//
//	printf("%d\n", d);
//	// 00000000000000000000000000000011 - 3的补码
//	// 11111111111111111111111111111011 - -5的补码
//	// 11111111111111111111111111111011 - 按位或
//
//	int e = a ^ b;
//	// 00000000000000000000000000000011 - 3的补码
//	// 11111111111111111111111111111011 - -5的补码
//	// 11111111111111111111111111111000 - 按位异或（补码）
//	// 11111111111111111111111111110111
//	// 10000000000000000000000000001000 - 按位异或（原码）结果为-8
//	printf("%d\n", e);
//
//	return 0;
//}

//交换两个整型变量(不创建临时变量）
//int main ()
//{
//	int a = 3;
//	int b = 5;
//
//	//int c = 0;//临时变量
//	printf("交换前：a=%d,b=%d\n", a, b);
//	/*c = a;
//	a = b;
//	b = c;*/
//
//	/*a = a + b;
//	b = a - b;
//	a = a - b;*/ // 有底层逻辑错误，不能解决所有情况
//
//	a = a ^ b;
//	b = a ^ b;//a^b^b
//	a = a ^ b;//a^b^a
//
//	printf("交换后：a=%d,b=%d\n", a, b);
//
//
//	return 0;
//}

//求一个整数存储在内存中的二进制位中1的个数
//int main()
//{
//	int a = 0;
//	int b = 1;
//	int count = 0;
//	int num = a;
//	if (a < 0)
//	{
//		num = -(a + 1);
//	}
//	while (num)
//	{
//		int c = num & b;
//		count += c;
//		num = num >> 1;
//	}
//	if (a < 0)
//	{
//		count = 32 - count;
//	}
//	printf("%d\n", count);
//
//	return 0;
//}

//赋值操作符
//int main()
//{
//	int x,y;
//	int a = x = y = 10;//  = 就是赋值操作符，可以连续赋值但不建议
//	return 0;
//}
//   3 = 100 不合法
//左值是可以放在等号左边的，一般是一块空间
//右值是可以放在等号右边的，一般是一个值或一块空间的内容。


//复合赋值符 += -= *= /= %= >>= <<=  &= |= ^=
//int main() 
//{
//	int a = 0;
//	a = a + 10;
//	a += 10;
//	a -= 5;
//	return 0;
//}


//单目操作符，只有一个操作数
//int main()
//{
//	// ! 逻辑取反  真转为假，假转为真（!0为1）
//	int flag = 0;
//	if (!flag)
//	{
//		printf("hehe\n");
//	}
//	// - 负值
//	// + 正值 , 该操作符作用不大
//	// & 取地址
//	// sizeof 操作数的类型长度
//	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
//	sizeof flag;
//	printf("%d\n", sizeof(arr));//40
//	printf("%d\n", sizeof(int [10]));//40
//	// ~ 按(2进制)位取反（补码）
//	// -- 
//	// ++
//	// * 间接访问操作符（解引用操作符）
//	//(类型) 强制类型转换
//	return 0;
//}
//int main()
//{
//	int a = 0;
//	// ~按位取反
//	// 00000000000000000000000000000000
//	// 11111111111111111111111111111111 - 补码
//	// 11111111111111111111111111111110 - 反码
//	// 10000000000000000000000000000001 - 原码 -> -1
//
//	printf("%d \n", ~a);
//	return 0;
//}
//int main()
//{
//	int a = 10;
//	a |= (1 << 2);
//	printf("%d\n", a);
//	a &= ~(1 << 2);
//	printf("%d\n", a);
//
//
//	// 00000000000000000000000000001010 第三位改为1 
//	// 00000000000000000000000000000100   |   1<<2
//	// 00000000000000000000000000001110
//	// 改回去
//	// 11111111111111111111111111111011 &   ~00000000000000000000000000000100 就是 (~(1<<2))
//	// 00000000000000000000000000001010 
//	return 0;
//}
// fab  - 对整数求绝对值
// fabs - 对小数求绝对值

//int main()
//{
//	int a = 10;
//	int b = 20;
//	printf("交换前：a=%d,b=%d\n", a, b);
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("交换后：a=%d,b=%d\n", a, b);
//	return 0;
//}

// 获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列
int main()
{
	int n = 0;
	scanf("%d", &n);
	//00000000000000000000000000001010
	printf("奇数位：");
	for (int i = 31; i >= 1; i -= 2)
	{
		printf("%d ", (n >> i) & 1);
	}
	printf("\n偶数位：");
	for (int i = 30; i >= 0; i -= 2)
	{
		printf("%d ", (n >> i) & 1);
	}
	return 0;
}